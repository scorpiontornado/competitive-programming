//  - 2:03pm, immediately recognised as convex hull
//  - can't remember how to do it off the top of my head, asked Yiheng, not
//    _supposed_ to use pre-prepared code but let's pretend I printed it out
//    beforehand
//  - 2:05pm, impl! Feeling Graham scan vibes though ngl given the ccw input &
//  output
//  - looked @ sample, only want vertices of the polygon.
//  - Wondering if Andrew's monotone chain gives in clockwise/ccw order?
//    - otherwise, need to try & remember graham scan...
//    - wait, is alr in counterclockwise order, should use graham scan to avoid
//      an unnecessary sort... 2:14pm, go! ... & we want counterclockwise,
//      change ccw
//    - also makes it fairer, have to type out myself
//  - ll prob unnecessary, doubt the bounds are that tight...
//  - oh also, W - no three points are collinear. Dw too much abt ccw >=0 vs >0
// (btw, msft C/C++ intellisense wasn't working, chmod issue again. installed
//  clangd, disabled msft intellisense, working like a charm! Even type hints
//  for auto!)
//  - 2:23pm nearly done main function & pondering Graham scan impl
//  - 2:30pm, maybe done?? Think with points sorted in ccw order already,
//    half_hull gives a full convex hull! Vs Andrew's ..., sorts by x coord,
//    breaking ties by y coord - then reverses & repeats
//  - test, 2:31pm... have dropped to 8th btw, 7th on 3 solves, 5th & 6th on 4,
//    4th on 5, 2nd & 3rd on 7, 1st (sanctioned...) on 8 - KDHLGAFJ
//  - uh oh... 2:35pm, outputting 5 pts, all are correct but wrong order??
//    (nvm if there are multiple valid solutions, may output any one of them....
//    still wrong though?)
//  - ok looks like my points are in clockwise order, odd..
//  - wait, 2:38pm, my alg is just fundamentally flawed omg... no diagonals
//  allowed,
//    but some right turns are? Also, no need for points to be points on
//    original shape
//    - wonder if I could start w convex hull then quantise the points or smth?
//  - turns out my points ARE in clockwise order but yep, missing a corner...
//    - Note that two consecutive points must have either the same x-coordinate
//      or the same y-coordinate
// - 2:43pm, entirely new direciton.. consider sliding edges? Or, perhaps ..
// shortcut
//   if alr seen that x coord etc?
//  - 2:44pm, stumped ngl, felt so close rah.... leave it!
//  - idk wait quantising feels so promising... if a new pt would have a diff
//    x and y coord to the prev, insert another point.. where?
//  - wait, no three points are collinear, so sides must alternate vert/hori
//  - so, insert pseudo-point on stack based on the coord pts[i] and pts[i-1]
//  have in common,
//    with the other ... from the top of stack?
//  - 2:56pm, miraculously passing sample cases? (Just rotated)
//    - 2:57pm, submit!
//    - Rah!! wrong answer, passed samples... Did have a warning though, meh
//  - I could be REALLY close, or I could be incredibly far off... 2:59pm,
//    2 hours remaining, swap. & cut the yap!!

//  - 3:00pm, new idea.. edge sliding? Bit heartbreaking but oh well..
//    - ccw order, so we know if we go ..
//  - wait, ccw order of the shape doesn't mean ccw order vs origin?
//    - hard to know if impl issue vs algo issue
//  - Theorem: if the past 3 points are counter-clockwise, take them. Else, if
//    clockwise, extend the previous line..?
//    - or.. need a way to "cancel out" two clockwise turns in a row?
//      Promising, might have edge cases, very much influenced by sample
//    - Doesn't even need to be 2 in a row? If the points from x=5-7 were removed,
//      still valid to only take ccw turns, 4x3 rectangle... Same min dist
//  - Realised I'm recreating something v similar to what I had, modified Graham's
//  - 3:14pm stuck again, going in circles.... move on
//  - 4:59pm, just randomly had an idea... too late lol! Was thinking abt moving
//    (5:00pm!!) edges, realised you can just draw one big rectangle around the
//    whole shape? Kinda a rectangle hull, in a way? I hypothesise you just need
//    to take 4 points to optimally cover any shape. Threw me off, cause none of
//    the samples had m=4 !!
//    - But yeah think my Graham Scan algo was either fundamentally flawed (bandaid patch
//      with the pseudo-points/snapping to grid), or it's related to - just cause
//      the points were given in ccw order on the shape, doesn't necesarily mean
//      they're polar sorted in ccw order around the first point..? Even in the
//      diagram! Polar sort would give (1,2), (1,5), (7,5), (5,2), (7,1), (5,1)?
// But yeah no requirement the bike path has to hug the edges or anything, just must be
// as short as possible!!

// 5:09pm, talked to (Miles?) - sactioned country 3, came 1st - yeah, D was
// just: draw a rectangle around the whole thing, becaues it's manhattan
// distance - can slide edges

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// From COMP4128 lecture code, 11. Comp Geom
typedef pair<ll, ll> pt;
#define x first
#define y second

pt operator-(pt a, pt b) { return pt(a.x - b.x, a.y - b.y); }

ll cross(pt a, pt b) { return a.x * b.y - a.y * b.x; }

// // true if left or straight
// bool ccw(pt a, pt b, pt c) { return cross(b - a, c - a) >= 0; }

// vector<pt> half_hull(vector<pt> pts) {
//   vector<pt> res;
//   for (int i = 0; i < pts.size(); i++) {
//     // ccw means we have a left turn; we don't want that
//     while (res.size() >= 2 &&
//            ccw(res[res.size()-2], res[res.size()-1], pts[i])) {
//       res.pop_back();
//     }
//     res.push_back(pts[i]);
//   }
//   return res;
// }

// vector<pt> convex_hull(vector<pt> pts) {
//   sort(pts.begin(), pts.end());
//   vector<pt> top = half_hull(pts);

//   reverse(pts.begin(), pts.end());
//   vector<pt> bottom = half_hull(pts);

//   // remove repeated endpoints
//   top.pop_back(); bottom.pop_back();
//   vector<pt> res(top.begin(), top.end());
//   res.insert(res.end(), bottom.begin(), bottom.end());
//   return res;
// }

// true if left, false if right/straight
bool ccw(pt a, pt b, pt c) { return cross(b - a, c - a) > 0; }

// Graham scan, returns points in counterclockwise order
// Assumes input points are in counterclockwise order
//  (sorted by polar coordinate around the bottom point, breaking ties by
//   distance - closest first.... wait, not necessary/given here??)
vector<pt> convex_hull(vector<pt> pts) {
  vector<pt> res;
  for (int i = 0; i < pts.size(); i++) {
    // Only want left turns (ccw = true)
    while (res.size() >= 2 &&
           (not ccw(res[res.size() - 2], res[res.size() - 1], pts[i]))) {
      res.pop_back();
    }
    //! Check if new point would make it diagonal. If so, insert "pseudo-point"
    if (res.size() >= 1 && i >= 1) { // TODO: check
      pt top = res[res.size() - 1];
      if (pts[i].x != top.x && pts[i].y != top.y) {
        // XXX: what if i = 0??
        if (pts[i].x == pts[i - 1].x) {
          // TODO: check
          res.push_back(pt(pts[i].x, top.y));
        } else { // y same
          res.push_back(pt(top.x, pts[i].y));
        }
      }
    }

    res.push_back(pts[i]);
  }
  return res;
}

// vector<pt> convex_hull(vector<pt> pts) {
//   vector<pt> res;
//   for (int i = 0; i < pts.size(); i++) {
//     // Only want left turns (ccw = true)
//     while (res.size() >= 2 &&
//            (not ccw(res[res.size() - 2], res[res.size() - 1], pts[i]))) {
//       res.pop_back();
//       // TODO
//     }
//     // TODO
//     res.push_back(pts[i]);
//   }
//   return res;
// }

int main() {
  int n;
  cin >> n;

  vector<pt> pts;
  for (int i = 0; i < n; i++) {
    int x, y;
    cin >> x >> y;
    pts.emplace_back(x, y);
  }

  auto hull = convex_hull(pts);

  cout << hull.size() << "\n";
  for (auto p : hull) {
    cout << p.first << ' ' << p.second << '\n';
  }
}
